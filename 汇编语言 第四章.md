# 汇编语言 第四章 第一个程序

## 4.1 一个程序从写出到执行的过程

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，编写汇编源程序: 这一步的结果是产生一个存储源程序的文本文件。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二步，对源程序进行编译链接: 首先使用汇编语言编译程序对文本文件中的源程序进行编译，产生**目标文件**；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件，其中可执行文件包含两部分: 1) **程序**(从源程序中汇编指令翻译过来的机器码)和数据(源程序中定义额数据) 和 2) **相关的描述信息**，比如程序有多大，要占用多少内存空间等。这一步的结果是产生了一个可在操作系统中运行的可执行文件。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三步，执行可执行文件的程序: 操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。

## 4.2 源程序

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下就是一段简单的汇编语言源程序

```s
assume cs:codesg

codesg segment

    mov ax,0123H
    mov bx,0456H
    add ax,bx
    add ax,ax

    mov ax,4c00H
    int 21H

codesg ends

end
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面对程序进行说明。

**1. 伪指令**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终被CPU运行。而伪指令没有对应的机器指令，最终也不被CPU执行。那么谁来执行伪指令呢？答案是伪指令由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上述程序中出现了3种伪指令。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) `XXX segment`和`XXX ends`: 这是一对成对使用的伪指令，这也是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。其功能是定义一个段。并且一个段必须要有一个名称来标识，即前述的`XXX`。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。因此一个有意义的汇编程序至少要有一个段，这个段用来存放代码。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) `end`: 其是一个汇编程序的结束标识。如果程序的结尾出没有`end`，那么编译器在编译程序时，无法知道程序在哪结束。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) `assume`: 这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用`segment ... ends`定义的段相关联。通过`assume`说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。`assume`并不是现在一定深入理解不可的伪指令，以后我们在编程时，记得用`assume`将有特定用途的段和相关的段寄存器关联起来即可。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如在上述的程序中，我们在`segment ... ends`中定义了一个名为`codesg`的段，这个段中存放代码，所以这个段是一个代码段。因此在程序的开头，用`assume cs:codesg`将其与CPU中的段寄存器`cs`联系起来。

**2. 源程序中的“程序”**

<div class="separator" style="clear: both;"><a href="https://raw.githubusercontent.com/lidongze0629/blog/main/images/assembly-language-4.1.png" style="display: block; padding: 1em 0px; text-align: center;"><img alt="" border="0" data-original-height="1202" data-original-width="1726" src="https://raw.githubusercontent.com/lidongze0629/blog/main/images/assembly-language-4.1.png" width="320" /></a></div>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常我们将文本文件中的所有内容统一称为源程序，而将源程序中最终由计算机执行、处理的指令或数据，称为程序。显然，伪指令不是程序的一部分。真正的程序经过编译、连接后转变伪机器码，存储在可执行文件中，这个过程如图所示。

**3. 标号**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;汇编源程序中，除了汇编指令和伪指令，还有一些标号，比如`codesg`，一个标号指代了一个地址。比如上述程序中的的`codesg`在`segment`前面，做为一个段的名称，这个段的名称最终将被编译、连接程序处理伪一个段的段地址。

**4. 程序的结构**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下述程序展现了汇编程序中的基本要素，是一个简单框架，完成`2^3`任务。

```s
assume cs:codesg

codesg segment

    mov ax,2
    add ax,ax
    add ax,ax

codesg ends

end
```

**5. 程序返回**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前位置，我们已经知道，最后产生的是可执行文件，那么这个可执行文件是怎样得到运行的呢？下面我们以DOS(一个单任务操作系统)的基础上，简单地讨论一下这个问题。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个程序`P2`在可执行文件中，则必须有一个正在运行的程序`P1`，将`P2`从可执行文件中加载入内存后，将CPU的控制权交给`P2`，此时`P2`才能得以运行。`P2`开始运行后，`P1`暂停运行。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而当`P2`运行完毕后，应该将CPU的控制权交还给使它得以运行的程序`P1`，此后`P1`继续运行。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们知道，一个程序结束后，将CPU的控制权交还给使它得以运行的程序，我们称这个过程为: **程序返回**。那么，如何返回呢？应该在程序的末尾处添加返回的程序段。即对应下述两条指令。

```s
mov ax,4c00H
int 21H
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两条指令所实现的功能就是返回。在目前阶段，我们不用去理解`int 21H`指令的含义，后续章节中我们会深入研究。

**6. 语法错误和逻辑错误**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，程序在编译时被编译器发现的错误是语法错误；而在编译后，运行时发生的错误是逻辑错误。一般逻辑错误很难发现，需要DEBUG调试。


## 4.3 编辑源程序

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以用任意文本文件编辑源程序。在DOS下也可通过`edit`进行编辑。


## 4.4 编译