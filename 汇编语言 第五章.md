# 汇编语言 第五章 [BX]和loop指令

## 前言

- [bx]和内存单元的描述

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`[bx]`和之前提到的`[0]`有些类似。而且我们已经知道，要完整地描述一个内存单元，需要两种信息: 1) 内存单元地址；2) 内存单元的长度 (类型)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如当用`[0]`表示一个内存单元的时候，`0`表示内存单元的偏移地址，段地址存默认在`ds`寄存器中，单元的长度(类型)可以由具体指令中的其它操作对象(比如寄存器)指出。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`[bx]`同样表示一个内存单元，它的偏移地址存在`bx`寄存器中。

- loop

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章节中，我们讲解`[bx]`和`loop`指令的应用、意义和相关的内容。

- 我们定义的描述性的符号: "()"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了描述上的简介，在以后的章节中，我们将使用`( )`来表示一个寄存器或一个内存单元的内容。比如`(ax)`表示寄存器`ax`中的内容；`(20000H)`表示内存20000H单元的内容。

- 约定符号`idata`表示常量

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`mov ax,[idata]`就代表`mov ax,[1]`、`mov ax,[2]`等。


## 5.1 [BX]

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面指令的功能如下:

```s
mov ax,[bx]
mov [bx],ax
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`bx`寄存器中存放的数据作为一个偏移地EA，段地址SA默认在`ds`寄存器中，之后将对应SA:EA中的数据送入`ax`或将`ax`中的数据送入SA:EA中。


## 5.2 Loop指令

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`loop`指令的格式为`loop 标号`，CPU执行loop指令的时候，要进行两步操作，1) `(cx) = (cx) - 1`；2) 判断`cx`中的值，不为零则转至标号处执行程序，如果为零则向下执行。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的描述中我们可以看出，`cx`中影响着`loop`指令的执行结果。通常，**注意，我们说的是通常**，我们用`loop`指令实现循环功能，`cx`中存放循环次数。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节我们指讲解`loop`指令的的功能，关于如何实现转至标号处的细节，将在后面的课程中讲解。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下述程序的任务是计算`2^12`

```s
assume cs:code

code segment
    mov ax,2
    mov cx,11

    s: add ax,ax
       loop s

    mov ax,4c00H
    int 21H

code ends

end
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的的过程中，我们可以总结处使用`cx`和`loop`指令相配合实现循环功能的3个要点

- `cx`中存放的是循环次数
- `loop`指令中的标号所识别的地址要在前面
- 要循环执行的程序段，要写在标号和`loop`指令的中间

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用`cx`和`loop`指令相配合实现循环功能的程序框架如下：

```s
mov cx,循环次数

s: 循环执行的程序段
   loop s
```

## 5.3 在Debug中跟踪用loop指令实现的循环程序

<div class="separator" style="clear: both;"><a href="https://raw.githubusercontent.com/lidongze0629/blog/main/images/assembly-language-5.1.png" style="display: block; padding: 1em 0px; text-align: center;"><img alt="" border="0" data-original-height="1202" data-original-width="1726" src="https://raw.githubusercontent.com/lidongze0629/blog/main/images/assembly-language-5.1.png" width="320" /></a></div>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图中我们可以看到，类似于`loop s`的代码中的标号`s`已经变成了一个地址`0012H`。这样，CPU执行到`loop 0012H`的时候，第一步现将`cx`减1，如果`cx`不为0，则将IP设为`0012H`。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一节我们在介绍两个Debug中常用的命令。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`g`命令，`g 0012`表示执行程序当前的代码段(段地址在CS中)的0012H处，也就是说，其将使Debug从当前的CS:IP指向的指令开始执行，一直到(IP)=0012H为止。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`p`命令，如果在Debug中我们进入到了循环，则可以使用`p`命令来一次性将循环执行完。当然也可以使用`g`命令指向循环结束后的下一个IP地址。


## 5.4 Debug和汇编编译器masm对指令的不同处理

